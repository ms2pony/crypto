

# This file was *autogenerated* from the file /home/tam/crypto/miscellaneous/mersen_reduction/vec_opration.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_26 = Integer(26); _sage_const_1 = Integer(1); _sage_const_256 = Integer(256); _sage_const_224 = Integer(224); _sage_const_96 = Integer(96); _sage_const_64 = Integer(64); _sage_const_260 = Integer(260); _sage_const_2 = Integer(2); _sage_const_0xfffffffeffffffffffffffffffffffffffffffff00000000ffffffffffffffff = Integer(0xfffffffeffffffffffffffffffffffffffffffff00000000ffffffffffffffff)
from sage.all_cmdline import *
# mersen素数下的

def bn2vec(bn:list):
    """
    return: 向量形式
    """
    # 算出bn有几位(2^26进制)
    len=bn[_sage_const_0 ]//_sage_const_26 +_sage_const_1 
    vec=[_sage_const_0  for i in range(len)]
    if(not mod(bn[_sage_const_0 ],_sage_const_26 )):
        vec[-_sage_const_1 ]=_sage_const_1 
    for bn_e in bn:
        vec_e=mod(bn_e,_sage_const_26 )
        vecIndex=bn_e//_sage_const_26 
        if(vec_e):
            vec[vecIndex]=vec_e
    vec.reverse()
    return vec

# 测试函数 bn2vec`
def bn2vecTest():
    p1=[_sage_const_256 , _sage_const_224 , _sage_const_96 , _sage_const_64 , _sage_const_1 ]
    p2=[_sage_const_260 ]
    print(bn2vec(p1),bn2vec(p2))

def mersenReduction(bn, module):
    while len(bin(bn))>_sage_const_260 +_sage_const_2 :
        leftShifCount=len(bin(bn))-len(bin(module))-_sage_const_1 
        # print(leftShifCount)
        correction=module<<leftShifCount
        # print(bin(correction))
        bn-=correction
        # break

    return bn

def mersenReductionTest():
    """测试函数mersenReduction
    """
    bn=_sage_const_2 **_sage_const_260 
    p_sm2=_sage_const_0xfffffffeffffffffffffffffffffffffffffffff00000000ffffffffffffffff 
    # bin(mersenReduction(bn,p_sm2))
    print(bin(mersenReduction(bn,p_sm2)))


def convert(a_str):
    a_strOutput=""
    subpower=_sage_const_0 
    addpower=_sage_const_0 
    
    subpowerPre=_sage_const_0 
    # addpowerPre=0

    
    while a_str:
        a_len=len(a_str)
        a_0index=a_str.find('0')
        
        # print(a_0index)
        if a_0index>_sage_const_1  or a_0index==-_sage_const_1 :  
            addpower=a_len    
            subpower=a_len-a_0index if a_0index>_sage_const_1  else _sage_const_0 
            if subpowerPre-addpower==_sage_const_1 :
                a_strOutput=a_strOutput.replace("-2^{{{}}}".format(subpowerPre),"-2^{{{}}}-2^{{{}}}".format(addpower,subpower))
                subpowerPre=subpower
            elif addpower-subpower==_sage_const_1 :
                # a_strOutput+="+2^{{{}}}-2^{{{}}}".format(a_len,a_len-a_0index if a_0index>1 else 0)
                a_strOutput+="+2^{{{}}}".format(subpower)
                # addpowerPre=addpower
                subpowerPre=subpower
            else:
                a_strOutput+="+2^{{{}}}-2^{{{}}}".format(addpower,subpower)
                subpowerPre=subpower

        elif a_0index==_sage_const_1 :
            
            # a_strOutput+="+2^{{{}}}".format(a_len-1)
            addpower=a_len-_sage_const_1 
            if subpowerPre-addpower==_sage_const_1 :
                a_strOutput=a_strOutput.replace("-2^{{{}}}".format(subpowerPre),"-2^{{{}}}".format(addpower))
                subpowerPre=addpower
            else:
                a_strOutput+="+2^{{{}}}".format(addpower)
                # addpowerPre=addpower

        a_str=None if a_0index==-_sage_const_1  else a_str[a_0index+_sage_const_1 :]

    

    # return a_strOutput[1:].replace('2^{0}','1')
    return a_strOutput[_sage_const_1 :].replace('2^0','1')

def convertTest():
    # 测试函数convert
    # p_sm2=0xfffffffeffffffffffffffffffffffffffffffff00000000ffffffffffffffff
    # p_sm2Str=bin(p_sm2)[2:]
    bn=_sage_const_2 **_sage_const_260 
    p_sm2=_sage_const_0xfffffffeffffffffffffffffffffffffffffffff00000000ffffffffffffffff 
    # bin(mersenReduction(bn,p_sm2))
    a_str=bin(mersenReduction(bn,p_sm2))[_sage_const_2 :]
    print(convert(a_str))

if __name__ == "__main__":
    convertTest()

